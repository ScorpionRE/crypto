import base64
import binascii
import codecs
import linecache

import libnum
from Crypto.Cipher import PKCS1_OAEP

from Crypto.Util.number import *
from Crypto.PublicKey import RSA
import gmpy2
import sympy

n = 16278524034278364842964386062476113517067911891699789991355982121084973951738324063305190630865511554888330215827724887964565979607808294168282995825864982603759381323048907814961279012375346497781046417204954101076457350988751188332353062731641153547102721113593787978587135707313755661153376485647168543680503160420091693269984008764444291289486805840439906620313162344057956594836197521501755378387944609246120662335790110901623740990451586621846212047950084207251595169141015645449217847180683357626383565631317253913942886396494396189837432429078251573229378917400841832190737518763297323901586866664595327850603
p = 114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513
q = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088834871
d = 937
e = 7
c = 233922571487642239338389353101375907901870146879339907748330005077163804549982910295997854209602125331296735160274207808076451704339519819069366591418923688143155556035591167327872516333743015613946429118551433347882990043807324725604388681022504560278684502677553524083438621899398189907914544119451717593054523504174077342428078456429952575765717742744140233431887729958738207365698731669771643137089379083369539214317778545076312503592588439176758596132439425782655932573036619819489463908301337498696844004802925584318906915406000139671192771992655977201482805322026244772609295368992963134910385475668041714168510928654232781015426587226600864264068711737019462722962060678748310645251021628539330572990804920075521195431225076370448633660796375744525617443441144761585295483119540577163689618373570776507164516014863082991902515274689520853523096434043362022416676023835666120584472533272972435244689845821293740074430



#dp，dq，c求m (RSA_CRT leaks)
# dp =6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929
# dq =783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041
# def r_dpq(dp,dq):
#     invq = gmpy2.invert(q,p)
#     mp = pow(c,dp,p)
#     mq = pow(c,dq,q)
#     m = (((mp-mq)*invq) % p) * q + mq
#     m = hex(m)
#     print("m:"+ str(m))
#     print("n2s"+str(libnum.n2s(m)))
# r_dpq(dp,dq)

#n,dp,e求m dp泄露
# dp = 734763139918837027274765680404546851353356952885439663987181004382601658386317353877499122276686150509151221546249750373865024485652349719427182780275825
#
#
# for i in range(1,e):
#     if (dp * e - 1) % i == 0:
#         p = gmpy2.mpz(((dp * e - 1) // i) + 1)
#         if n % p == 0:
#             q= n // p
#             print(p)
#             print(q)
#             phi = gmpy2.mpz((p-1)*(q-1))
#             d = gmpy2.invert(gmpy2.mpz(e),phi) % phi
#             break
#
# print(d)
# #d = gmpy2.mpz(d)
# print("DP,d:"+str(d))
# M = pow(c,d,n)
# print("十进制M："+ str(M))
# print(hex(M))
# print(codecs.decode(hex(M)[2:],'hex'))
# print(long_to_bytes(M))

#共模攻击(使用相同的模数 N、不同的私钥时，加密同一明文消息时即存在共模攻击)
# e1 = 42
# e2 = 3
# c1 = 45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384
# c2 = 13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158
# n = 15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039
# gcd,s,t = gmpy2.gcdext(e1,e2)
# if s < 0:
#     s = -s
#     c1 = gmpy2.invert(c1,n)
# if t < 0:
#     t = -t
#     c2 = gmpy2.invert(c2,n)
#
# M = gmpy2.powmod(c1,s,n)*gmpy2.powmod(c2,t,n) % n
# m = hex(M)
# print(m)
# print(codecs.decode(m[2:],'hex'))
# m = m[2:]
# missing_padding = 4 - len(m) % 4
# if missing_padding:
#     m += '=' * missing_padding
# print(base64.b64decode(m))


# #多文件共模攻击，n相同，e不同
# e1 = 1697
# e2 = 599
# n = 785095419718268286866508214304816985447077293766819398728046411166917810820484759314291028976498223661229395009474063173705162627037610993539617751905443039278227583504604808251931083818909467613277587874545761074364427549966555519371913859875313577282243053150056274667798049694695703660313532933165449312949725581708965417273055582216295994587600975970124811496270080896977076946000102701030260990598181466447208054713391526313700681341093922240317428173599031624125155188216489476825606191521182034969120343287691181300399683515414809262700457525876691808180257730351707673660380698973884642306898810000633684878715402823143549139850732982897459698089649561190746850698130299458080255582312696873149210028240898137822888492559957665067936573356367589784593119016624072433872744537432005911668494455733330689385141214653091888017782049043434862620306783436169856564175929871100669913438980899219579329897753233450934770193915434791427728636586218049874617231705308003720066269312729135764175698611068808404054125581540114956463603240222497919384691718744014002554201602395969312999994159599536026359879060218056496345745457493919771337601177449899066579857630036350871090452649830775029695488575574985078428560054253180863725364147
#
# #多行c拼接
#
# with open('HUB1','rb') as f:
#     c1 = gmpy2.mpz(f.read())
#     print(c1)
# with open('HUB2','rb') as f:
#     c2 = gmpy2.mpz(f.read())
#     print(c2)
# gcd,s,t = gmpy2.gcdext(e1,e2)
# # c1 = libnum.s2n(c1)
# # c2 = libnum.s2n(c2)
# # print(c1)
# # print(c2)
# if s < 0:
#     s = -s
#     c1 = gmpy2.invert(c1,n)
# if t < 0:
#     t = -t
#     c2 = gmpy2.invert(c2,n)
#
# M = gmpy2.powmod(c1,s,n)*gmpy2.powmod(c2,t,n) % n
# m = hex(M)
# print(m)
# print(codecs.decode(m[2:],'hex'))
# m = m[2:]
# m = codecs.decode(m[2:],'hex')
# m = str(m).split("\\n")
# # missing_padding = 4 - len(m) % 4
# # if missing_padding:
# #     m += '=' * missing_padding
# for i in range(1,len(m)):
#     print(m[i])
#     missing_padding = 4 - len(m[i]) % 4
#     if missing_padding:
#         m[i] += '=' * missing_padding
#     print(base64.b64decode(m[i]))
# #strip处理

# 分行加密，解密
# m = ""
# with open("data.txt",'r') as f:
#     for c in f.readlines():
#         m += chr(pow(int(c), d, n))
# print(m)


# 小公钥指数攻击（一般e为3） 对K进行爆破，只要k满足 kn + C能够开e次方就可以得明文
# k = 0
# while 1:
#     res = gmpy2.iroot(c + k * n, e)
#     if res[1] == True:
#         a = int(res[0])
#         print(a)
#         print(int(res[0]))
#
#         print(libnum.n2s(int(res[0])))
#         break
#     k = k + 1


#爆破，给出e的范围
# for e in range(50000,70001):
#     if gmpy2.gcd(e,phi) == 1:
#             d = gmpy2.invert(e, phi)
#             m = pow(c, d, n)
#             flag = hex(m)[2:]
#             #不是偶数就要加0？？？但是libnum不可用？？？
#             if (len(str(flag)) % 2 == 1):
#                 flag = '0' + flag
#             print(codecs.decode(flag,'hex'))

#小加密指数 （m^e还是比n小，直接对c开e次方

# e = 0x10001
#
# x = linecache.getline('rsa_16m',2).strip()
# print(x)
# c = int(x[4::],16)
# m = gmpy2.iroot(c,e)[0]
# print(long_to_bytes(m))


#低解密指数广播攻击，多个n,c找n的公因数

# n1= p*q
# c1= 7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596
#
# n2= p*127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088834871
# c2= 262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124
#
# n=[]
# c=[]
# for i in range(1,3):
#     n.append(eval('n'+str(i)))
#     c.append(eval('c'+str(i)))
#进制转换
#for i in range(len(n)):
#     n[i]=int(str(n[i]),5)
#     c[i]=int(str(c[i]),5)
#print(n)
# def CRT(data):
#     plian=0
#     m=1
#     for x in data:
#         m=m*x[1]
#     for z,n in data:
#         mi=m//n
#         mr=gmpy2.invert(mi,n)
#         plian=plian+z*(mr*mi)
#     return plian%m
#
# data=list(zip(c,n))
# f=CRT(data)
# for e in range(2,97):
#     m2,h=gmpy2.iroot(f,e)
#     if(h==1):
#         m2 = hex(m2)
#         print(m2)
#         print(codecs.decode(m2[2:],'hex'))

#模不互素，n1,n2不互素,有e
# n1 = 13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037
# n2 =12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047
# c1 = 12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120
#
#
# p1 = gmpy2.gcd(n1,n2)
# q1 = n1/p1








#d泄露，遍历
#p,q是1024位的,因此两者相乘不低于2048位,通过运算可知ed-1为2064位,因此k一定小于16位
# e_d_1=e*d-1
# p=0
# q=0
# for k in range(pow(2,15),pow(2,16)):
#     if e_d_1%k==0:
#         p=sympy.prevprime(gmpy2.iroot(e_d_1//k,2)[0])
#         q=sympy.nextprime(p)
#         if (p-1)*(q-1)*k==e_d_1:
#             break
# n=p*q

#rsa的变形、n=p*q*r   威尔逊定理
# def get_pq(A,B):
#     tmp = 1
#     for i in range(B+1,A-1):
#         tmp *= i
#         tmp %= A
#     tmp_inv = gmpy2.invert(tmp,A)
#     return sympy.nextprime(tmp_inv)
#
# A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
# B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596
#
# A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
# B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026
#
# p = get_pq(A1,B1)
# q = get_pq(A2,B2)
# print(p)
# print(q)
# r = n//p//q
# phi = (p-1)*(q-1)*(r-1)
# d = gmpy2.invert(e, phi)
# print("d:"+ str(d))

#rabin算法，e=2
# inv_p = gmpy2.invert(p, q)
# inv_q = gmpy2.invert(q, p)
#
# # 计算mp和mq
# mp = pow(c, (p + 1) // 4, p)
# mq = pow(c, (q + 1) // 4, q)
#
# # 计算a,b,c,d
# a = (inv_p * p * mq + inv_q * q * mp) % n
# b = n - int(a)
# c = (inv_p * p * mq - inv_q * q * mp) % n
# d = n - int(c)
#
# for i in (a, b, c, d):
#     print(bin(i)[2:]) #输出二进制
#     s = '%x' % i
#     if len(s) % 2 != 0:
#         s = '0' + s
#     print(s.decode('hex'))

#计算d
#print(gmpy2.lcm(p-1,q-1))   #最小公倍数

phi_n = (p - 1) * (q - 1)
#若无法直接求逆元d
print(gmpy2.gcd(e,phi_n))
d = gmpy2.invert(e, phi_n)
print("d:"+ str(d))

#根据c求m
M = pow(c,d,p*q)

#e不是素数，需要分解，变形后，m是之前的x次方
#M = gmpy2.iroot(M,2)[0]

print("十进制M："+ str(M))
print(long_to_bytes(M))
m = gmpy2.iroot(M,2)[0]
print(m)
print(hex(m))
print(long_to_bytes(m))
#print(libnum.n2s(M))



#从公钥文件中获取n、e的值
# with open("pubkey2.pem",'rb') as f:
#     pub = RSA.importKey(f.read())
#     n = pub.n
#     e = pub.e
#     print(n,'\n',e)
#
#
# #解密文件
#
# key_info = RSA.construct((n, e, int(d), p, q))
# key = RSA.importKey(key_info.exportKey())
# key = PKCS1_OAEP.new(key)
# f = open('myflag1', 'r').read()
# c = base64.b64decode(f)
# flag = key.decrypt(c)
# print(flag)




